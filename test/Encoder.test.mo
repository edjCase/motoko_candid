import Array "mo:base/Array";
import Blob "mo:base/Blob";
import Char "mo:base/Char";
import Debug "mo:base/Debug";
import Decoder "../src/Decoder";
import Encoder "../src/Encoder";
import Iter "mo:base/Iter";
import Bool "mo:base/Bool";
import Nat "mo:base/Nat";
import Float "mo:base/Float";
import Nat8 "mo:base/Nat8";
import Principal "mo:base/Principal";
import Type "../src/Type";
import Value "../src/Value";
import Arg "../src/Arg";
import { test } "mo:test";

let base : Nat8 = 0x10;

let symbols = [
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
];
/**
  * Encode an unsigned 8-bit integer in hexadecimal format.
  */
func encodeW8(w8 : Nat8) : Text {
  let c1 = symbols[Nat8.toNat(w8 / base)];
  let c2 = symbols[Nat8.toNat(w8 % base)];
  "0x" # Char.toText(c1) # Char.toText(c2);
};

func areEqual(b1 : [Nat8], b2 : [Nat8]) : Bool {
  if (b1.size() != b2.size()) {
    return false;
  };
  for (i in Iter.range(0, b1.size() - 1)) {
    if (b1[i] != b2[i]) {
      return false;
    };
  };
  true;
};

func toHexString(array : [Nat8]) : Text {
  Array.foldLeft<Nat8, Text>(
    array,
    "",
    func(accum, w8) {
      var pre = "";
      if (accum != "") {
        pre #= ", ";
      };
      accum # pre # encodeW8(w8);
    },
  );
};

func testCase(bytes : [Nat8], t : Type.Type, arg : Value.Value) {
  test(
    "Encoder test for type: " # debug_show (t) # " and value: " # debug_show (arg),
    func() {
      let actualBytes : [Nat8] = Blob.toArray(Encoder.encode([{ value = arg; type_ = t }]));
      if (not areEqual(bytes, actualBytes)) {
        Debug.trap("Failed Byte Check.\nExpected Bytes: " # toHexString(bytes) # "\nActual Bytes:   " # toHexString(actualBytes) # "\nValue: " # debug_show (arg));
      };
      let args : ?[Arg.Arg] = Decoder.decode(Blob.fromArray(bytes));
      switch (args) {
        case (null) {
          Debug.trap("Failed decoding.\nExpected Type: " # debug_show (t) # "\nExpected Value: " # debug_show (arg) # "\nBytes: " # toHexString(bytes));
        };
        case (?args) {
          if (args.size() != 1) {
            Debug.trap("Too many args: " # Nat.toText(args.size()));
          };
          let actualArg : Arg.Arg = args[0];
          if (not Type.equal(t, actualArg.type_)) {
            Debug.trap("Failed Type Check.\nExpected Type: " # debug_show (t) # "\nActual Type: " # debug_show (actualArg.type_));
          };
          if (not Value.equal(arg, actualArg.value)) {
            Debug.trap("Failed Value Check.\nExpected Value: " # debug_show (arg) # "\nActual Value: " # debug_show (actualArg.value));
          };
        };
      };
    },
  );
};

// Nat
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7D, 0x00], #nat, #nat(0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7D, 0x01], #nat, #nat(1));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7D, 0x7F], #nat, #nat(127));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7D, 0xE5, 0x8E, 0x26], #nat, #nat(624485));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7D, 0x80, 0x80, 0x98, 0xF4, 0xE9, 0xB5, 0xCA, 0x6A], #nat, #nat(60000000000000000));

// Nat8
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7B, 0x00], #nat8, #nat8(0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7B, 0x10], #nat8, #nat8(16));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7B, 0x63], #nat8, #nat8(99));

// Nat16
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7A, 0x00, 0x00], #nat16, #nat16(0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7A, 0x10, 0x00], #nat16, #nat16(16));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7A, 0xE7, 0x03], #nat16, #nat16(999));

// Nat32
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x79, 0x00, 0x00, 0x00, 0x00], #nat32, #nat32(0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x79, 0x10, 0x00, 0x00, 0x00], #nat32, #nat32(16));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x79, 0xEA, 0x49, 0x08, 0x00], #nat32, #nat32(543210));

// Nat64
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], #nat64, #nat64(0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x78, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], #nat64, #nat64(16));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x78, 0xEA, 0x49, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00], #nat64, #nat64(543210));

// Int
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x00], #int, #int(0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x10], #int, #int(16));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x7C], #int, #int(-4));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x71], #int, #int(-15));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0xBC, 0x7F], #int, #int(-68));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0xE5, 0x8E, 0x26], #int, #int(624485));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0xC0, 0xBB, 0x78], #int, #int(-123456));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x80, 0x01], #int, #int(128));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7C, 0x80, 0x80, 0xE8, 0x8B, 0x96, 0xCA, 0xB5, 0x95, 0x7F], #int, #int(-60000000000000000));

// Int8
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x77, 0x00], #int8, #int8(0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x77, 0x10], #int8, #int8(16));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x77, 0x63], #int8, #int8(99));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x77, 0xF1], #int8, #int8(-15));

// Int16
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x76, 0x00, 0x00], #int16, #int16(0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x76, 0x10, 0x00], #int16, #int16(16));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x76, 0xF1, 0xFF], #int16, #int16(-15));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x76, 0x0F, 0x27], #int16, #int16(9999));

// Int32
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x75, 0x00, 0x00, 0x00, 0x00], #int32, #int32(0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x75, 0x10, 0x00, 0x00, 0x00], #int32, #int32(16));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x75, 0xF1, 0xFF, 0xFF, 0xFF], #int32, #int32(-15));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x75, 0xFF, 0xFF, 0x00, 0x00], #int32, #int32(65535));

// Int64
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], #int64, #int64(0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x74, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], #int64, #int64(16));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x74, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF], #int64, #int64(-15));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x74, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00], #int64, #int64(4294967295));

// Float32
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x73, 0x00, 0x00, 0x80, 0x3F], #float32, #float32(1.0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x73, 0x10, 0x06, 0x9E, 0x3F], #float32, #float32(1.23456));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x73, 0xB7, 0xE6, 0xC0, 0xC7], #float32, #float32(-98765.4321));

// // Float64
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x3F], #float64, #float64(1.0));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x72, 0x38, 0x32, 0x8F, 0xFC, 0xC1, 0xC0, 0xF3, 0x3F], #float64, #float64(1.23456));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x72, 0x8A, 0xB0, 0xE1, 0xE9, 0xD6, 0x1C, 0xF8, 0xC0], #float64, #float64(-98765.4321));

// Bool
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7E, 0x01], #bool, #bool(true));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7E, 0x00], #bool, #bool(false));

// Text
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x71, 0x00], #text, #text(""));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x71, 0x01, 0x41], #text, #text("A"));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x71, 0x2B, 0x54, 0x68, 0x65, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6B, 0x20, 0x62, 0x72, 0x6F, 0x77, 0x6E, 0x20, 0x66, 0x6F, 0x78, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x73, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x7A, 0x79, 0x20, 0x64, 0x6F, 0x67], #text, #text("The quick brown fox jumps over the lazy dog"));

// Principal
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x68, 0x01, 0x00], #principal, #principal(Principal.fromText("aaaaa-aa")));
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x68, 0x01, 0x1D, 0xFE, 0x97, 0x48, 0xF3, 0x57, 0x95, 0x3E, 0x20, 0xAC, 0xA9, 0x0D, 0xC2, 0x41, 0xC3, 0x37, 0x2E, 0xFE, 0x4A, 0x3A, 0xEE, 0xA0, 0xD7, 0xA9, 0xB9, 0xA1, 0x36, 0x8D, 0xE7, 0x02], #principal, #principal(Principal.fromText("g4gvl-fx6s5-epgv4-vhyqk-zkiny-ja4gn-zo7zf-dv3va-26u3t-ijwrx-tqe")));

// Null
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x7F], #null_, #null_);

// Reserved
testCase([0x44, 0x49, 0x44, 0x4C, 0x00, 0x01, 0x70], #reserved, #reserved);

// Opt
testCase([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6E, 0x7C, 0x01, 0x00, 0x00], #opt(#int), #opt(#null_));
testCase([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6E, 0x7C, 0x01, 0x00, 0x01, 0x2A], #opt(#int), #opt(#int(42)));
testCase([0x44, 0x49, 0x44, 0x4C, 0x02, 0x6E, 0x7C, 0x6E, 0x00, 0x01, 0x01, 0x01, 0x01, 0x2A], #opt(#opt(#int)), #opt(#opt(#int(42))));

// Vector
testCase([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6D, 0x7C, 0x01, 0x00, 0x00], #vector(#int), #vector([]));
testCase([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6D, 0x7C, 0x01, 0x00, 0x02, 0x01, 0x02], #vector(#int), #vector([#int(1), #int(2)]));

// Record
testCase([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6C, 0x01, 0x01, 0x7C, 0x01, 0x00, 0x2A], #record([{ tag = #hash(1); type_ = #int }]), #record([{ tag = #hash(1); value = #int(42) }]));
testCase([0x44, 0x49, 0x44, 0x4C, 0x01, 0x6C, 0x02, 0xD3, 0xE3, 0xAA, 0x02, 0x7E, 0x86, 0x8E, 0xB7, 0x02, 0x7C, 0x01, 0x00, 0x01, 0x2A], #record([{ tag = #name("foo"); type_ = #int }, { tag = #name("bar"); type_ = #bool }]), #record([{ tag = #name("foo"); value = #int(42) }, { tag = #name("bar"); value = #bool(true) }]));

testCase(
  [0x44, 0x49, 0x44, 0x4C, 0x04, 0x6E, 0x7C, 0x6C, 0x01, 0xA7, 0x8A, 0x83, 0x99, 0x08, 0x00, 0x6E, 0x01, 0x6C, 0x01, 0xA7, 0x8A, 0x83, 0x99, 0x08, 0x02, 0x01, 0x03, 0x01, 0x00],
  #record([{
    tag = #name("selfRef");
    type_ = #opt(#record([{ tag = #name("selfRef"); type_ = #opt(#int) }]));
  }]),
  #record([{
    tag = #name("selfRef");
    value = #opt(#record([{ tag = #name("selfRef"); value = #opt(#null_) }]));
  }]),
);

// Same type, multiple fields https://github.com/edjCase/motoko_candid/issues/7
let userType = #record([
  {
    tag = #name("age");
    type_ = #nat;
  },
  {
    tag = #name("name");
    type_ = #text;
  },
]);
testCase(
  [0x44, 0x49, 0x44, 0x4C, 0x02, 0x6C, 0x02, 0xBF, 0xE9, 0xA7, 0x02, 0x7D, 0xCB, 0xE4, 0xFD, 0xC7, 0x04, 0x71, 0x6C, 0x02, 0xB0, 0xF0, 0xF5, 0x04, 0x00, 0xF4, 0x9E, 0x9F, 0xA2, 0x06, 0x00, 0x01, 0x01, 0x17, 0x05, 0x4A, 0x61, 0x6D, 0x65, 0x73, 0x18, 0x06, 0x53, 0x74, 0x65, 0x76, 0x65, 0x6E],
  #record([
    {
      tag = #name("first");
      type_ = userType;
    },
    {
      tag = #name("second");
      type_ = userType;
    },
  ]),
  #record([
    {
      tag = #name("first");
      value = #record([
        {
          tag = #name("age");
          value = #nat(23);
        },
        {
          tag = #name("name");
          value = #text("James");
        },
      ]);
    },
    {
      tag = #name("second");
      value = #record([
        {
          tag = #name("age");
          value = #nat(24);
        },
        {
          tag = #name("name");
          value = #text("Steven");
        },
      ]);
    },
  ]),
);

// Variant
testCase(
  [0x44, 0x49, 0x44, 0x4C, 0x03, 0x6C, 0x05, 0xC4, 0xA7, 0xC9, 0xA1, 0x01, 0x79, 0xDC, 0x8B, 0xD3, 0xF4, 0x01, 0x79, 0x8D, 0x98, 0xF3, 0xE7, 0x04, 0x7C, 0xE2, 0xD8, 0xDE, 0xFB, 0x0B, 0x79, 0x89, 0xFB, 0x97, 0xEB, 0x0E, 0x71, 0x6B, 0x01, 0xCF, 0xA0, 0xDE, 0xF2, 0x06, 0x7F, 0x6B, 0x02, 0x9C, 0xC2, 0x01, 0x00, 0xE5, 0x8E, 0xB4, 0x02, 0x01, 0x01, 0x02, 0x01, 0x00],
  #variant([
    {
      tag = #name("ok");
      type_ = #record([
        {
          tag = #name("total");
          type_ = #nat32;
        },
        {
          tag = #name("desktop");
          type_ = #nat32;
        },
        {
          tag = #name("time");
          type_ = #int;
        },
        {
          tag = #name("mobile");
          type_ = #nat32;
        },
        {
          tag = #name("route");
          type_ = #text;
        },
      ]);
    },
    {
      tag = #name("err");
      type_ = #variant([{
        tag = #name("NotFound");
        type_ = #null_;
      }]);
    },
  ]),
  #variant({
    tag = #name("err");
    value = #variant({
      tag = #name("NotFound");
      value = #null_;
    });
  }),
);

// Func
testCase(
  [0x44, 0x49, 0x44, 0x4C, 0x03, 0x6E, 0x7D, 0x6D, 0x77, 0x6A, 0x02, 0x7C, 0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01, 0x02, 0x01, 0x01, 0x00, 0x12, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x4E, 0x4E, 0x53, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E],
  #func_({
    modes = [#query_, #oneway];
    argTypes = [#int, #opt(#nat)];
    returnTypes = [#vector(#int8)];
  }),
  #func_({
    method = "ExecuteNNSFunction";
    service = Principal.fromText("aaaaa-aa");
  }),
);

// Service
testCase(
  [0x44, 0x49, 0x44, 0x4C, 0x04, 0x6E, 0x7D, 0x6D, 0x77, 0x6A, 0x02, 0x7C, 0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x69, 0x01, 0x12, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x4E, 0x4E, 0x53, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x02, 0x01, 0x03, 0x01, 0x00],
  #service({
    methods = [(
      "ExecuteNNSFunction",
      {
        modes = [#query_, #oneway];
        argTypes = [#int, #opt(#nat)];
        returnTypes = [#vector(#int8)];
      },
    )];
  }),
  #service(Principal.fromText("aaaaa-aa")),
);

// Recursion

testCase(
  [0x44, 0x49, 0x44, 0x4C, 0x02, 0x6E, 0x01, 0x6C, 0x01, 0xA7, 0x8A, 0x83, 0x99, 0x08, 0x00, 0x01, 0x01, 0x01, 0x00],
  #recursiveType({
    id = "rec_1";
    type_ = #record([{
      tag = #name("selfRef");
      type_ = #opt(#recursiveReference("rec_1"));
    }]);
  }),
  #record([{
    tag = #name("selfRef");
    value = #opt(#record([{ tag = #name("selfRef"); value = #opt(#null_) }]));
  }]),
);

// Duplicate Types are merged
testCase(
  [0x44, 0x49, 0x44, 0x4C, 0x02, 0x6E, 0x7C, 0x6B, 0x02, 0x31, 0x00, 0x92, 0xFF, 0xC9, 0x93, 0x04, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01],
  #variant([
    {
      tag = #name("1");
      type_ = #opt(#int);
    },
    {
      tag = #name("dup1");
      type_ = #opt(#int);
    },
  ]),
  #variant({
    tag = #name("1");
    value = #opt(#int(1));
  }),
);

// Nested record
testCase(
  [0x44, 0x49, 0x44, 0x4C, 0x03, 0x6E, 0x7F, 0x6C, 0x03, 0xBF, 0xE9, 0xA7, 0x02, 0x7D, 0x9C, 0x9E, 0xBB, 0xFE, 0x06, 0x00, 0x82, 0xBB, 0x82, 0xA5, 0x0F, 0x7E, 0x6C, 0x02, 0xCB, 0xE4, 0xFD, 0xC7, 0x04, 0x71, 0xC2, 0xB9, 0xDB, 0xDA, 0x0A, 0x01, 0x01, 0x02, 0x06, 0x63, 0x61, 0x6E, 0x64, 0x69, 0x64, 0x20, 0x00, 0x00],
  #record([
    {
      type_ = #record([
        { type_ = #nat; tag = #name("age") },
        { type_ = #opt(#null_); tag = #name("email") },
        { type_ = #bool; tag = #name("registered") },
      ]);
      tag = #name("details");
    },
    {
      type_ = #text;
      tag = #name("name");
    },
  ]),
  #record([
    {
      tag = #name("details");
      value = #record([
        { tag = #name("age"); value = #nat(32) },
        { tag = #name("email"); value = #opt(#null_) },
        { tag = #name("registered"); value = #bool(false) },
      ]);
    },
    {
      tag = #name("name");
      value = #text("candid");
    },
  ]),
);

// Array in record
testCase(
  [0x44, 0x49, 0x44, 0x4C, 0x02, 0x6D, 0x71, 0x6C, 0x02, 0xCB, 0xE4, 0xFD, 0xC7, 0x04, 0x71, 0x80, 0xD8, 0xB2, 0x90, 0x0C, 0x00, 0x01, 0x01, 0x06, 0x63, 0x61, 0x6E, 0x64, 0x69, 0x64, 0x02, 0x05, 0x69, 0x74, 0x65, 0x6D, 0x31, 0x05, 0x69, 0x74, 0x65, 0x6D, 0x32],
  #record([{ type_ = #vector(#text); tag = #name("items") }, { type_ = #text; tag = #name("name") }]),
  #record([{ tag = #name("items"); value = #vector([#text("item1"), #text("item2")]) }, { tag = #name("name"); value = #text("candid") }]),
);
